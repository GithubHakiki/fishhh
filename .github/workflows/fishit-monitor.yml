name: Fish-It Event Monitor

on:
  schedule:
    - cron: '*/10 * * * *' # Every 10 minutes
  workflow_dispatch: # Manual trigger

jobs:
  check-event:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install Puppeteer
        run: npm install puppeteer
      
      - name: Check for Fish-It Events
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          node << 'EOF'
          const puppeteer = require('puppeteer');
          const fs = require('fs');

          (async () => {
            console.log('Launching browser...');
            const browser = await puppeteer.launch({
              headless: 'new',
              args: ['--no-sandbox', '--disable-setuid-sandbox']
            });
            
            const page = await browser.newPage();
            
            // Set timezone to WIB (Asia/Jakarta) so Roblox shows correct time
            await page.emulateTimezone('Asia/Jakarta');
            await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36');
            
            console.log('Navigating to Fish-It page...');
            await page.goto('https://www.roblox.com/games/121864768012064/Fish-It', {
              waitUntil: 'networkidle2',
              timeout: 30000
            });
            
            // Wait for event tiles to load
            await page.waitForSelector('.experience-events-tile', { timeout: 5000 }).catch(() => {
              console.log('No event tiles found');
            });
            
            // Extract event data with more details
            const events = await page.evaluate(() => {
              const tiles = document.querySelectorAll('.experience-events-tile');
              return Array.from(tiles).map(tile => {
                const titleElement = tile.querySelector('.game-card-name');
                const dateElement = tile.querySelector('.game-card-info');
                const imageElement = tile.querySelector('img');
                const linkElement = tile.querySelector('a');
                const descriptionElement = tile.querySelector('.info-label');
                
                // Get raw date text
                const rawDate = dateElement?.textContent?.trim() || '';
                
                // Check if event is live now (case insensitive, handle variations)
                const lowerDate = rawDate.toLowerCase();
                const isLiveNow = lowerDate === 'new content' || 
                                 lowerDate === 'newcontent' || 
                                 lowerDate.includes('new content');
                
                return {
                  id: tile.id,
                  title: titleElement?.textContent?.trim() || 'Unknown Event',
                  date: rawDate,
                  isLiveNow: isLiveNow,
                  image: imageElement?.src || '',
                  link: linkElement?.href || '',
                  description: descriptionElement?.textContent?.trim() || ''
                };
              });
            });
            
            console.log('Found ' + events.length + ' event(s)');
            
            await browser.close();
            
            if (events.length === 0) {
              console.log('No events found');
              process.exit(0);
            }
            
            const currentEvent = events[0];
            console.log('Current event: ' + JSON.stringify(currentEvent, null, 2));
            
            // CRITICAL: Read last event ID with proper existence check
            let lastEventId = '';
            let wasNotified = false;
            
            try {
              if (fs.existsSync('last_event_id.txt')) {
                const savedData = fs.readFileSync('last_event_id.txt', 'utf8').trim();
                console.log('File exists, content: ' + savedData);
                
                if (savedData.includes('|')) {
                  const parts = savedData.split('|');
                  lastEventId = parts[0].trim();
                  wasNotified = parts[1].trim() === 'true';
                } else if (savedData.length > 0) {
                  lastEventId = savedData;
                  wasNotified = true; // Assume old format was already notified
                }
              } else {
                console.log('File does not exist - first run');
              }
            } catch (e) {
              console.log('Error reading file: ' + e.message);
            }
            
            console.log('Last event ID: "' + lastEventId + '"');
            console.log('Current event ID: "' + currentEvent.id + '"');
            console.log('Was notified: ' + wasNotified);
            
            // STRICT CHECK: If event ID is the same, ALWAYS skip
            if (lastEventId && currentEvent.id === lastEventId) {
              console.log('*** EVENT ID IS THE SAME - SKIPPING NOTIFICATION ***');
              
              // Make absolutely sure it's marked as notified
              if (!wasNotified) {
                console.log('Marking as notified to prevent future attempts');
                fs.writeFileSync('last_event_id.txt', currentEvent.id + '|true');
              }
              
              process.exit(0);
            }
            
            // Only reach here if event ID is different
            console.log('*** NEW EVENT DETECTED - WILL SEND NOTIFICATION ***');
            
            // Send to Discord
            const discordWebhook = process.env.DISCORD_WEBHOOK;
            if (!discordWebhook) {
              console.error('DISCORD_WEBHOOK not set');
              process.exit(1);
            }
            
            // Parse date and convert to Unix timestamp for Discord
            let discordTimestamp = null;
            let eventTimeDisplay = '';
            
            if (currentEvent.isLiveNow) {
              // Event is happening NOW!
              discordTimestamp = Math.floor(Date.now() / 1000);
              eventTimeDisplay = 'üî¥ **HAPPENING NOW!**';
              console.log('Event is LIVE NOW');
            } else if (currentEvent.date) {
              try {
                // Parse date like "Sun, Feb 1, 8:00 AM" (WIB time from Puppeteer with Asia/Jakarta timezone)
                const dateMatch = currentEvent.date.match(/(\w+),\s+(\w+)\s+(\d+),\s+(\d+):(\d+)\s+(AM|PM)/);
                if (dateMatch) {
                  const dayName = dateMatch[1];
                  const month = dateMatch[2];
                  const day = dateMatch[3];
                  const hour = dateMatch[4];
                  const minute = dateMatch[5];
                  const ampm = dateMatch[6];
                  
                  // Convert to 24-hour format
                  let hour24 = parseInt(hour);
                  if (ampm === 'PM' && hour24 !== 12) hour24 += 12;
                  if (ampm === 'AM' && hour24 === 12) hour24 = 0;
                  
                  // Month mapping
                  const monthMap = {
                    'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5,
                    'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11
                  };
                  
                  // Create date object in WIB (UTC+7)
                  const year = new Date().getFullYear();
                  const dateObj = new Date(Date.UTC(
                    year, 
                    monthMap[month], 
                    parseInt(day), 
                    hour24 - 7, // Convert WIB to UTC by subtracting 7 hours
                    parseInt(minute)
                  ));
                  
                  // Get Unix timestamp (seconds)
                  discordTimestamp = Math.floor(dateObj.getTime() / 1000);
                  eventTimeDisplay = '<t:' + discordTimestamp + ':F>';
                  
                  console.log('Parsed date: ' + currentEvent.date + ' (WIB) -> Unix: ' + discordTimestamp);
                }
              } catch (e) {
                console.log('Could not parse date: ' + e.message);
                eventTimeDisplay = currentEvent.date;
              }
            }
            
            // Build embed
            const embed = {
              title: currentEvent.isLiveNow ? 'üî¥ Fish-It Event LIVE NOW!' : 'üé£ Fish-It Event Alert',
              url: currentEvent.link || 'https://www.roblox.com/events/' + currentEvent.id,
              color: currentEvent.isLiveNow ? 0xFF0000 : 0xFF6600,
              thumbnail: {
                url: currentEvent.image || 'https://tr.rbxcdn.com/180DAY-a9ff09dd1042a26b4364f92a4324ad2a/384/216/Image/Jpeg/noFilter'
              },
              fields: [],
              timestamp: new Date().toISOString(),
              footer: {
                text: 'Fish-It Event Watcher'
              }
            };
            
            // Event Name
            embed.fields.push({
              name: 'üìå Event Name',
              value: '**' + (currentEvent.title || 'Unknown Event') + '**\n_ _',
              inline: false
            });
            
            // Event Time/Status
            if (eventTimeDisplay) {
              embed.fields.push({
                name: currentEvent.isLiveNow ? '‚è∞ Status' : 'üïê Event Time',
                value: eventTimeDisplay + '\n_ _',
                inline: false
              });
            }
            
            // Description
            if (currentEvent.description) {
              embed.fields.push({
                name: 'üìù Details',
                value: currentEvent.description + '\n_ _',
                inline: false
              });
            }
            
            // Event ID and Link
            embed.fields.push({
              name: 'üîñ Event ID',
              value: '`' + currentEvent.id + '`',
              inline: true
            });
            
            embed.fields.push({
              name: '\u200B',
              value: '\u200B',
              inline: true
            });
            
            embed.fields.push({
              name: 'üîó Open Event',
              value: '[Click Here](https://www.roblox.com/events/' + currentEvent.id + ')',
              inline: true
            });
            
            console.log('Sending notification to Discord...');
            const response = await fetch(discordWebhook, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                embeds: [embed]
              })
            });
            
            if (response.ok) {
              console.log('Discord notification sent successfully');
              // Save event ID with notified=true
              fs.writeFileSync('last_event_id.txt', currentEvent.id + '|true');
              console.log('Saved event ID to file: ' + currentEvent.id + '|true');
            } else {
              const errorText = await response.text();
              console.error('Failed to send Discord notification: ' + response.status + ' - ' + errorText);
              // DO NOT save event ID if notification failed - will retry next time
              process.exit(1);
            }
          })();
          EOF
      
      - name: Commit and push event ID
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Pull latest changes first to avoid conflicts
          git pull origin ${{ github.ref_name }} --rebase || true
          
          # Add the file
          git add last_event_id.txt
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            # Commit with skip ci to avoid triggering workflow again
            git commit -m "Update event ID [skip ci]"
            
            # Push with retry mechanism (max 3 attempts)
            for i in 1 2 3; do
              echo "Attempting to push (attempt $i/3)..."
              if git push origin ${{ github.ref_name }}; then
                echo "Push successful"
                exit 0
              else
                echo "Push failed, retrying in 2 seconds..."
                sleep 2
                git pull origin ${{ github.ref_name }} --rebase || true
              fi
            done
            
            echo "Failed to push after 3 attempts"
            exit 1
          fi
